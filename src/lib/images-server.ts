/**
 * Server-side Image Utilities
 * 
 * Uses a pre-generated manifest (media-manifest.json) to resolve
 * image paths without needing the actual media files on disk.
 * This allows Vercel builds to work without the 700MB of media files.
 * 
 * The manifest is generated by: npx ts-node scripts/generate-media-manifest.ts
 * 
 * In PREVIEW BUILD mode:
 * - Returns only first image for galleries
 * - Uses /preview/ path prefix
 * - Limits lightbox to single image
 */

import { IS_PREVIEW_BUILD, mediaUrl } from './buildMode';
import mediaManifest from '../data/generated/media-manifest.json';

interface FileEntry {
  name: string;
  size: number;
}

const manifest = mediaManifest as {
  catalog: Record<string, FileEntry[]>;
  brands: Record<string, FileEntry[]>;
};

const CATALOG_PATH = IS_PREVIEW_BUILD ? '/preview/catalog/products' : '/catalog/products';
const BRAND_MARKI_PATH = IS_PREVIEW_BUILD ? '/preview/media/marki' : '/media/marki';

/**
 * Get gallery images for product detail (server-side only)
 * Scans the actual directory for *-gallery.webp files
 * Ordered by filename index (01, 02, 03...)
 * 
 * In PREVIEW mode: Returns only first card image
 */
export function getProductGalleryImages(slug: string): string[] {
  // In preview mode, return only the card image
  if (IS_PREVIEW_BUILD) {
    return [mediaUrl(`${CATALOG_PATH}/${slug}/01-card.webp`)];
  }
  
  const files = manifest.catalog[slug] || [];
  
  // Filter for gallery images only, sort by index
  const galleryImages = files
    .map(f => f.name)
    .filter((f) => f.endsWith('-gallery.webp'))
    .sort((a, b) => {
      const numA = parseInt(a.split('-')[0], 10);
      const numB = parseInt(b.split('-')[0], 10);
      return numA - numB;
    })
    .map((f) => mediaUrl(`${CATALOG_PATH}/${slug}/${f}`));

  return galleryImages.length > 0 ? galleryImages : [mediaUrl(`${CATALOG_PATH}/${slug}/01-gallery.webp`)];
}

/**
 * Get lightbox images for product detail (server-side only)
 * Scans for *-lightbox.webp files
 * 
 * In PREVIEW mode: Returns only first card image
 */
export function getProductLightboxImages(slug: string): string[] {
  // In preview mode, return only the card image
  if (IS_PREVIEW_BUILD) {
    return [mediaUrl(`${CATALOG_PATH}/${slug}/01-card.webp`)];
  }
  
  const files = manifest.catalog[slug] || [];
  
  const lightboxImages = files
    .map(f => f.name)
    .filter((f) => f.endsWith('-lightbox.webp'))
    .sort((a, b) => {
      const numA = parseInt(a.split('-')[0], 10);
      const numB = parseInt(b.split('-')[0], 10);
      return numA - numB;
    })
    .map((f) => mediaUrl(`${CATALOG_PATH}/${slug}/${f}`));

    // Fallback to gallery images if no lightbox images
    return lightboxImages.length > 0 ? lightboxImages : getProductGalleryImages(slug);
}

/**
 * STEP_FIXES_08: Strict exclude patterns for brand images
 * Shared between gallery and lightbox image collection
 */
const BRAND_IMAGE_EXCLUDE_PATTERNS = [
  'luxarte',
  'logo',
  'favicon',
  'apple-touch',
  'webclip',
  'manifest',
  'icon',
  'site-',
  'header-',
  'og-image',
  'twitter-',
  'social-',
];

/**
 * DEV ONLY: Log rejected images for debugging
 */
function debugLogRejectedImage(filename: string, reason: string): void {
  if (process.env.NODE_ENV === 'development') {
    console.warn(`[Brand Image Filter] Rejected: ${filename} — reason: ${reason}`);
  }
}

/**
 * Minimum file size for actual photos (in bytes)
 * Files smaller than this are likely logos/icons, not photos
 * 10KB threshold - logos are typically <5KB, photos are 30KB+
 */
const MIN_PHOTO_SIZE_BYTES = 10240;

/**
 * Get brand gallery images (server-side only)
 * Scans /public/media/marki/{brand-slug}/ for gallery-*-gallery.webp files
 * 
 * FILTERING RULES (STEP_FIXES_08 - FINAL FIX):
 * 1. Must end with -gallery.webp
 * 2. Must NOT match exclude patterns (luxarte, logo, favicon, etc.)
 * 3. Must be larger than MIN_PHOTO_SIZE_BYTES (filters out logo placeholders)
 * 
 * In PREVIEW mode: Returns empty array (no brand galleries)
 */
export function getBrandGalleryImages(brandSlug: string): string[] {
  // In preview mode, skip brand galleries
  if (IS_PREVIEW_BUILD) {
    return [];
  }
  
  // Map slugs to actual folder names (if different)
  const folderMap: Record<string, string> = {
    'roberto-cavalli-home-interiors': 'roberto-cavalli',
  };
  
  const folderName = folderMap[brandSlug] || brandSlug;
  const files = manifest.brands[folderName] || [];
  
  // Filter for gallery images only - exclude all non-content images
  const galleryImages = files
    .filter((f) => {
      const lower = f.name.toLowerCase();
      
      // Must be gallery webp
      if (!f.name.endsWith('-gallery.webp')) {
        return false;
      }
      
      // Check against exclude patterns
      for (const pattern of BRAND_IMAGE_EXCLUDE_PATTERNS) {
        if (lower.includes(pattern)) {
          debugLogRejectedImage(f.name, `matches exclude pattern: ${pattern}`);
          return false;
        }
      }
      
      // Check file size from manifest - reject small files (logos/placeholders)
      if (f.size < MIN_PHOTO_SIZE_BYTES) {
        debugLogRejectedImage(f.name, `file size ${f.size} < ${MIN_PHOTO_SIZE_BYTES} (logo/placeholder)`);
        return false;
      }
      
      return true;
    })
    .sort((a, b) => {
      // Extract number: gallery-01-gallery.webp → 01
      const numA = parseInt(a.name.replace('gallery-', '').split('-')[0], 10);
      const numB = parseInt(b.name.replace('gallery-', '').split('-')[0], 10);
      return numA - numB;
    })
    .map((f) => mediaUrl(`${BRAND_MARKI_PATH}/${folderName}/${f.name}`));

  return galleryImages;
}

/**
 * Shared function for brand photos (card + gallery use same source)
 * Returns hero photo and all gallery photos from the same filtered list
 * 
 * STEP_FIXES_08: Single source of truth for brand images.
 * The nasze-marki card should use hero (first gallery photo)
 * The brand detail page uses the full photos array
 */
export function getBrandPhotoSet(brandSlug: string): { hero: string | null; photos: string[] } {
  const photos = getBrandGalleryImages(brandSlug);
  const hero = photos.length > 0 ? photos[0] : null;
  return { hero, photos };
}

/**
 * Get brand lightbox images (server-side only)
 * Scans for gallery-*-lightbox.webp files
 * 
 * FILTERING RULES (same as gallery - STEP_FIXES_08):
 * Uses shared BRAND_IMAGE_EXCLUDE_PATTERNS + MIN_PHOTO_SIZE_BYTES
 * 
 * In PREVIEW mode: Returns empty array
 */
export function getBrandLightboxImages(brandSlug: string): string[] {
  // In preview mode, skip brand lightbox
  if (IS_PREVIEW_BUILD) {
    return [];
  }
  
  // Map slugs to actual folder names (if different)
  const folderMap: Record<string, string> = {
    'roberto-cavalli-home-interiors': 'roberto-cavalli',
  };
  
  const folderName = folderMap[brandSlug] || brandSlug;
  const files = manifest.brands[folderName] || [];
  
  const lightboxImages = files
    .filter((f) => {
      const lower = f.name.toLowerCase();
      if (!f.name.endsWith('-lightbox.webp')) return false;
      
      // Check against exclude patterns
      for (const pattern of BRAND_IMAGE_EXCLUDE_PATTERNS) {
        if (lower.includes(pattern)) {
          debugLogRejectedImage(f.name, `matches exclude pattern: ${pattern}`);
          return false;
        }
      }
      
      // Check file size from manifest - reject small files (logos/placeholders)
      if (f.size < MIN_PHOTO_SIZE_BYTES) {
        debugLogRejectedImage(f.name, `file size ${f.size} < ${MIN_PHOTO_SIZE_BYTES} (logo/placeholder)`);
        return false;
      }
      
      return true;
    })
    .sort((a, b) => {
      const numA = parseInt(a.name.replace('gallery-', '').split('-')[0], 10);
      const numB = parseInt(b.name.replace('gallery-', '').split('-')[0], 10);
      return numA - numB;
    })
    .map((f) => mediaUrl(`${BRAND_MARKI_PATH}/${folderName}/${f.name}`));

  // Fallback to gallery images if no lightbox images
  return lightboxImages.length > 0 ? lightboxImages : getBrandGalleryImages(brandSlug);
}
